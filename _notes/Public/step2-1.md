---
title: 머신러닝 노트(2-1)
feed: show
date: 06-10-2022
mathjax: true
toc: true
---

* TOC
{:toc}

이제 딥러닝을 구현하는 방법에서 실질적인 부분으로 넘어가보자. 하이퍼파라미터 튜닝부터 최적화 알고리즘의 속도를 높여 학습 알고리즘이 적정한 시간에 학습을 할 수 있는지 확인해보자. 

{:#Train/Dev/Test 세트}
# Train/Dev/Test 세트
훈련(_Train_), 개발(_Dev_), 테스트(_Test_) 세트를 어떻게 설정할지 결정하는 것은 좋은 성능을 내는 신경망을 얻는 데 중요하다. 은닉층의 개수, 유닛의 개수, 학습률 등 다양한 하이퍼파라미터들의 올바른 값을 신경망 개발 초기에 추측하는 것은 거의 불가능에 가깝다. 그래서 어떤 가정을 세우고 코드로 이를 검증한 다음 피드백을 통해 올바르게 조정한다.

오늘날 딥러닝은 자연어 처리, 컴퓨터 비전, 음성 인식, 광고, 보안, 물류 등 다양한 분야에 사용된다. 하지만 주의해야 할 점은 어떤 분야에 대한 하이퍼파라미터 선택의 직관이 다른 영역에는 거의 적용되지 않는다는 것이다. 그리고 최적의 하이퍼파라미터 선택지는 가지고 있는 데이터의 양, 컴퓨터 환경 설정 상태 등에 따라 달라지기 때문에 한 영역의 전문가라 해도 최적의 하이퍼파라미터를 첫 시도에 고르는 것은 매우 어렵다. 따라서 가정을 검증하고 반복하는 것이 중요하다.

훈련, 개발, 테스트 데이터를 나누는 전통적인 방법은 전체 데이터셋에서 일부는 훈련 세트, 일부는 교차 검증 세트(개발 세트), 테스트 세트로 나누는 것이다. 그래서 훈련 세트로 계속 모델을 학습시키고 적절한 때에 테스트 세트로 검증하는 것이 일반적인 작업 흐름이었다. 그래서 일반적으로 훈련, 테스트 세트를 70:30으로 나누거나, 훈련, 개발, 테스트 세트를 60:20:20으로 나누는 것이 일반적인 관행이었다.

하지만 오늘날의 100만 개 이상 규모의 빅데이터 샘플에서 개발 세트와 테스트 세트의 비율을 더 낮추는 것이 트렌드가 되었다. 왜냐하면 개발 세트는 서로 다른 모델을 평가할 정도면 충분하기 때문이다. 따라서 20% 만큼 큰 비율 없이 평가가 가능할 정도면 충분하기 때문에 그 비율이 낮아졌다. 같은 방식으로 테스트 세트 또한 최종 모델의 성능에 대한 신뢰할 수 있는 추정치를 얻는 것이 목표이기 때문에 그 비율이 낮아졌다.

그리고 오늘날의 관행 중 하나는 훈련 세트와 테스트 세트가 서로 일치하지 않는 것이다. 다른 데이터 소스를 이용해 훈련 세트와 테스트 세트를 각각 구성하는 것이다. 한가지 주의해야할 점은 훈련과 개발 세트는 동일한 데이터 소스에서, 그리고 테스트 세트는 다른 데이터 소스에서 구성하도록 해야 한다는 것이다. 

{:#편향(_Bias_)과 분산(_Variance_)}
# 편향(_Bias_)과 분산(_Variance_)
머신러닝 실무에서는 편향과 분산에 대한 수준 높은 이해가 필요하다. 높은 편향을 가지고 있는 경우 과소적합(_Underfit_)이 나타난다고 하고, 높은 분산(=낮은 편향)을 가지고 있는 경우 과적합이(_Overfit_) 나타난다고 한다. 

편향과 분산을 이해하기 위해선 훈련 세트 오차와 개발 세트 오차를 살펴보면 된다. 가령 네개의 이진분류 모델의 훈련 세트 오차와 개발 세트 오차가 다음과 같다고 하자.

||Model1|Model2|Model3|Model4|
|-|-:|-:|-:|-:|
|Train Set Error|1 %|15 %|15 %|0.5 %|
|Dev Set Error|11 %|16 %|30 %|1 %|

Model1의 경우는 훈련 세트에 대해서는 모델이 잘 분류하지만 개발 세트에 대해서는 잘 분류하지 못하는 경우이다. 즉 훈련 세트에 과적합이 되어 개발 세트에 대해서 일반화되지 못하는 경우이다. 이를 **높은 분산**을 가진다고 한다. 한편 Model2의 경우는 훈련 데이터에 대해서도 잘 맞지 않는다. 이를 과소적합이라 한다. 반면 이 모델은 합리적인 수준에서 개발 세트에 대해 일반화가 되었다. 개발 세트에 대한 성능이 훈련 세트에 대한 성능보다 1 %p정도만 차이가 나기 때문이다. 이 때를 **높은 편향**이라 부른다. Model3는 개발 세트에 대한 성능이 훈련 세트에 대한 성능보다 더 높다. 이 때는 **높은 분산**, **높은 편향** 모두에 해당하는 경우이다. 마지막 Model4의 경우는 편향과 분산 모두 낮은 경우이다. 이 경우는 Ground Truth에 해당하는 데이터셋의 오차율이 0 %에 수렴하는 것을 가정한 경우이다. 

이를 정리하면 다음과 같다.

|||
|-|-|
|높은 편향(_high bias_)|과소적합(_underfitting_)|
|높은 분산(_high variance_)|과대적합(_overfitting_)|

{:#머신러닝을 위한 기본 레시피}
# 머신러닝을 위한 기본 레시피
편향과 분산은 머신러닝 모델의 특징을 더 잘 파악할 수 있도록 도와준다. 또, 알고리즘의 성능을 더 체계적으로 개선시킬 수 있도록 도와준다. 처음 모델을 훈련시킨 후에 편향이 크다면 더 큰 규모의 신경망을 설정하여 더 많은 은닉층 혹은 은닉 유닛을 선택하는 것을 시도할 수 있다. 혹은 효과를 얻는 것이 확실하지는 않지만 문제에 더 잘맞을 것으로 기대되는 다른 형태의 신경망 아키텍처(ex. Drop-Out, CNN, etc.)를 도입할 수도 있다. 이러한 과정을 충분히 반복하면 많은 경우에 적은 편향을 갖는 모델을 얻을 수 있을 것이다.

편향을 적절한 수준으로 줄이고 나면 이제 분산을 해결할 차례이다. 분산과 관련한 지표를 얻기 위해서는 개발 데이터셋을 사용하면 된다. 만약 분산이 높다면 가능한 경우 더 많은 데이터를 수집하는 것을 시도할 수 있다. 그렇지 못한 경우 정규화를 시도할 수 있다. 혹은 다른 하이퍼파라미터, 신경망 아키텍처 등을 사용하여 신경망을 재설계하는 것도 방법이다.

이처럼 높은 편향과 분산을 해결하는 방법은 일반적으로 서로 다르다. 하지만 이러한 과정을 완전히 체계화하기는 어렵다. 이 방법들은 낮은 편향과 분산을 해결하기까지 반복적으로 사용된다. 그래서 문제가 높은 편향인지 분산인지 확인하고 그 결과 시도해 볼 수 있는 방법을 적절하게 선택한다. 예를 들어, 높은 편향 문제가 발생했을 때 더 많은 데이터를 얻는 것은 그리 효율적이지 못할 것이다. 다음은 높은 편향이나 높은 분산 문제를 해결하기 위해 일반적으로 시도할 수 있는 순서도이다.

<div class="mermaid">
%%{ init: { 'flowchart': { 'curve': 'linear' } } }%%
graph TD
    subgraph B [높은 편향]
        direction LR
        HB[높은 편향] -- Y --> HBS[- 더 큰 네트워크 <br/>- 신경망 아키텍처 재설계]
    end
    subgraph V [높은 분산]
        direction LR
        HV[높은 분산] -- Y --> HVS[- 더 많은 데이터 획득 <br/>- 정규화 <br/>- 신경망 아키텍처 재설계]
    end
    
B -- N --> V
V -- N --> END(END)
</div>

초기 머신러닝의 시대에는 편향-분산 트레이드 오프에 대해 많이 논의되었다. 그 이유는 시도할 수 있는 대다수의 방법들이 편향을 증가시키고 분산을 감소시키거나 그 반대의 결과를 가져왔기 때문이다. 하지만 오늘날 딥러닝 빅데이터 시대에 접어들면서 상황이 바뀌었다. 더 큰 네트워크를 훈련시키는 방법은 일반적으로 분산을 증가시키지 않고 편향만을 감소시킨다. 또 더 많은 데이터를 얻는 것은 많은 경우에 편향을 증가시키지 않으면서 분산을 감소시킨다. 이처럼 편향, 분산 각각에만 영향을 미치는 방법들이 고안됨에 따라서 편향-분산 트레이드 오프에 대한 논의는 줄어들었다.

> 본 노트는 Andrew Ng의 머신러닝 수업을 정리한 것임. 
> Andrew Ng, Machine learning lecture, [Youtube Link](https://www.youtube.com/playlist?list=PLkRLdi-c79HKEWoi4oryj-Cx-e47y_NcM)

> [이전 포스트](https://sol1archive.github.io/note/step1-5) | [다음 포스트](https://sol1archive.github.io/note/step2-2) 